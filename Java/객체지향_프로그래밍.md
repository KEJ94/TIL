# 들어가며

- 코드 분석 시간 증가
- 코드 변경 시간 증가

예제 1
```
long start = System.currentTimeMillis();
...
long end = System.currentTimeMillis();
long elapsed = end - start;
```
```
long start = System.nanoTime();
...
long end = System.nanoTime();
long elapsednano = end - start;
```

예제 2
```
int mode = 10;
if(mode == 10){
  ... 수십줄
}
if(mode != 10){
  ... 
} 
```
```
int mode = 10;
if(mode == 10){
  ...
  if(조건){
     mode = 20
  }
  ...
}
...
if(mode != 10){
  ...
  ...
}
```
예제 3
```
if(acc.getRegdate().isAfter(fiveDaysAgo)){
  acc.setMembership(REGULAR);
}
...
if(acc.getMembership() == REGULAR && acc.getExpDate().isAfter(now)){
  ... 유료 회원 기능
}
```
```
if(acc.getRegdate().isAfter(fiveDaysAgo)){
  acc.setMembership(REGULAR);
}
...
if((acc.getMembership() == REGULAR || acc.getMembership() == PRO) && acc.getExpDate().isAfter(now)){
  ... 유료 회원 기능
}
```

현재 기능을 제대로 제공하는것도 중요하지만 앞으로의 변화에 적응할 수 있는것도 그만큼 중요하다.
객체 지향 비용을 낮추기 위해서는 __캡슐화 + 다형성(추상화)__ 이 필요하다.

# 객체

```
// 인증 API
Account account = findOne(id);
if(account.getState() == DELETED){

}
```
요구사항이 늘어남
```
Account account = findOne(id);
if(account.getState () == DELETED || account.getBlockCount() > 0){

}
```
**시간이 갈수록 복잡해지고 수정할 곳이 많아지는 코드

### 객체란?
객체의 핵심은 __기능 제공__ 이다.  
객체는 제공하는 기능으로 정의  
내부적으로 가진 필드(데이터)로 정의하지 않음  
<br>
예: 회원 객체
- 암호 변경하기 기능
- 차단 여부 확인 하기 기능  
<br>

예: 소리 제어기
- 소리 크기 증가하기 기능
- 소리 크기 감소하기 기능

### 객체와 객체
객체와 객체는 기능을 사용해서 연결  
기능 사용 = 메서드 호출  
```
VolumnController volCont = new VolumnController();
volCont.increase(4);
volCont.decrease(3);
int currentVol = volCont.volume();
```

### 메시지
객체와 객체 상호 작용은 메시지를 주고 받는다고 표현한다.  
메서드를 호출하는 메시지, 리턴하는 메시지, 익셉션 메시지 

### 오해할 수 있는 부분
getter, setter 클래스 처럼 특별한 기능 없이 단순히 데이터에 접근하는 클래스는 객체라기 보다는 데이터 클래스에 가깝다.

### 결론
객체는 __기능으로 정의__ 한다.

# 캡슐화
- 데이터 + 관련 기능 묶기
- 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
  - 구현에 사용된 데이터의 상세 내용을 외부에 감춤
- 정보 은닉 의미 포함
- 외부에 영향 없이 객체 내부 구현 변경 가능

### 캡슐화를 하지 않으면
요구사항의 변화가 데이터 구조/사용에 변화를 발생시킴

### 캡슐화
캠슐화된 기능을 사용하는 코드 영향을 최소화 할 수 있다.  
기능에 대한 (의도) 이해를 높임

__Tell, Don't Ask__ 데이터를 달라 하지 말고 해달라고 하기
```
if(acc.getMembership() == REGULAR){
   ... 정회원 기능
}
```
위 처럼 데이터를 가져와서 자기가 판단하는게 아니고, 아래 처럼 판단을 해달라고 지시하는 것
```
if(acc.hasRegularPermission()){
   ... 정회원 기능
}
```

__Demeter's Law__ 
- 메서드에서 생성한 객체의 메서드만 호출
- 파라미터로 받은 객체의 메서드만 호출
- 필드로 참조하는 객체의 메서드만 호출
```
acc.getExpDate().isAfter(now);
Date date = acc.getExpDate();
date.isAfter(now);
```
```
acc.isExpired();
acc.isValid(now);
```

### 정리
캡슐화는 기능의 구현을 외부에 감춘다.  
캡슐화를 통해 기능을 사용하는 코드에 영향을 주지 않고 (또는 최소화) 내부 구현을 변경할 수 있는 유연함


# 캡슐화 연습
예제 1
```
// 변경전
if(mem.getVerificationEmailStatus() != 2){
    return AuthResult.NO_EMAIL_VERIFIED;
}
```
```
// 변경후
if(!mem.isEmailVerified()){
    return AuthResult.NO_EMAIL_VERIFIED;
}

public class Member{
    private int verificationEmailStatus;
    public boolean isEmailVerified(){
        return verificationEmailStatus == 2;
    }
}
```
예제 2
```
// 변경전
Timer t = new Timer();
t.startTime = System.currentTimeMillis();
...
t.stopTime = System.currentTimeMillis();
long elaspedTime = t.stopTime - t.startTime;

public Class Timer {
    public long startTime;
    public long stopTime;
}
```
```
// 변경후
Timer t = new Timer();
t.start();
...
t.stop();
long time = t.elapsedTime(MILLISECOND);

public class Timer {
    private long startTime;
    private long stopTime;

    public void start(){
        this.startTime = System.currentTimeMillis();
    }

    public void stop(){
        this.stopTime = System.currentTimeMillis();
    }

    public long elapsedTime(TimeUnit unit){
        switch(unit){
            case MILLISECOND:
                return stopTime - startTime;
        }
    }
}
```
# 다형성과 추상화
